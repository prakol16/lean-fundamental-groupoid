import category_theory.category.Groupoid
import category_theory.groupoid
import topology.category.Top.basic
import topology.homotopy.basic
import topology.homotopy.fundamental_groupoid
import topology.constructions
import category_theory.functor
import category_theory.natural_isomorphism
import groupoid_products
import topology.path_connected
import path_homotopy_products

noncomputable theory

abbreviation œÄ := fundamental_groupoid.fundamental_groupoid_functor

-- Two objects of a groupoid in same component are isomorphic

-- œÄ (X √ó Y) = œÄ X √ó œÄ Y
section
universe u

parameters {I : Type u} (X : I ‚Üí Top.{u})


def pi_prod_X_to_prod_pi_X : (œÄ.obj (Top.of (Œ† i, X i))).Œ± 
  ‚•§ Œ† i, (œÄ.obj (X i)).Œ± :=
{
  obj := Œª g, g,
  map := Œª v‚ÇÅ v‚ÇÇ p, Œª i, homotopy.product.path_proj.quotient i p,
  map_id' := by { intro x, ext i, exact homotopy.product.proj_id_is_id.quotient i x, },
  map_comp' :=
  begin
    intros x y z f g,
    ext i,
    exact homotopy.product.homproj_commutes_with_comp i f g,
  end
}


def prod_pi_X_to_pi_prod_X : (Œ† i : I, (œÄ.obj (X i)).Œ±)
        ‚•§ (œÄ.obj (Top.of (Œ† i, X i))).Œ± := 
{
  obj := Œª g, g,
  map := Œª v‚ÇÅ v‚ÇÇ p, homotopy.product.path_prod.quotient p,
  map_id' := homotopy.product.id_product_is_id.quotient,
  map_comp' :=
  begin
    intros x y z f g,
    exact (homotopy.product.hompath_trans_commutes_with_product f g).symm,
  end
}

@[simp]
lemma def_pi_prod_X_to_prod_pi_X {x y : (œÄ.obj (Top.of (Œ† i, X i))).Œ±} {f : x ‚ü∂ y} 
  : pi_prod_X_to_prod_pi_X.map f = Œª i : I, homotopy.product.path_proj.quotient i f := rfl

@[simp]
lemma def_prod_pi_X_to_pi_prod_X {x y : Œ† i : I, (œÄ.obj (X i)).Œ±}
           {f : x ‚ü∂ y} : prod_pi_X_to_pi_prod_X.map f = homotopy.product.path_prod.quotient f := rfl 

lemma iso‚ÇÅ : pi_prod_X_to_prod_pi_X ‚ãô prod_pi_X_to_pi_prod_X = ùü≠ _ :=
begin
  apply category_theory.functor.ext; intros,
  { simp, }, { refl, },
end

lemma iso‚ÇÇ : prod_pi_X_to_pi_prod_X ‚ãô pi_prod_X_to_prod_pi_X = ùü≠ _ :=
begin
  apply category_theory.functor.ext; intros,
  { simp, }, { refl, },
end


end

